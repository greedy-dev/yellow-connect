// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: operator.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum NotificationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case channelOpening // = 1
  case channelOpened // = 2
  case channelClosed // = 3
  case challengeStarted // = 4
  case challengeCleared // = 5
  case challengeFinished // = 6
  case marginUpdated // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .channelOpening
    case 2: self = .channelOpened
    case 3: self = .channelClosed
    case 4: self = .challengeStarted
    case 5: self = .challengeCleared
    case 6: self = .challengeFinished
    case 7: self = .marginUpdated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .channelOpening: return 1
    case .channelOpened: return 2
    case .channelClosed: return 3
    case .challengeStarted: return 4
    case .challengeCleared: return 5
    case .challengeFinished: return 6
    case .marginUpdated: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [NotificationType] = [
    .unspecified,
    .channelOpening,
    .channelOpened,
    .channelClosed,
    .challengeStarted,
    .challengeCleared,
    .challengeFinished,
    .marginUpdated,
  ]

}

public enum ChannelStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case opening // = 1
  case `open` // = 2
  case challenging // = 3
  case closed // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .opening
    case 2: self = .open
    case 3: self = .challenging
    case 4: self = .closed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .opening: return 1
    case .open: return 2
    case .challenging: return 3
    case .closed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ChannelStatus] = [
    .unspecified,
    .opening,
    .open,
    .challenging,
    .closed,
  ]

}

public struct VersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct VersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetChallengeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Core_Address {
    get {return _address ?? Core_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Core_Address? = nil
}

public struct GetChallengeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var challenge: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AuthenticateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signature: String = String()

  public var address: Core_Address {
    get {return _address ?? Core_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Core_Address? = nil
}

public struct AuthenticateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jwt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TradeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trade: Core_Trade {
    get {return _trade ?? Core_Trade()}
    set {_trade = newValue}
  }
  /// Returns true if `trade` has been explicitly set.
  public var hasTrade: Bool {return self._trade != nil}
  /// Clears the value of `trade`. Subsequent reads from it will return its default value.
  public mutating func clearTrade() {self._trade = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trade: Core_Trade? = nil
}

public struct TradeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trade: Core_Trade {
    get {return _trade ?? Core_Trade()}
    set {_trade = newValue}
  }
  /// Returns true if `trade` has been explicitly set.
  public var hasTrade: Bool {return self._trade != nil}
  /// Clears the value of `trade`. Subsequent reads from it will return its default value.
  public mutating func clearTrade() {self._trade = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trade: Core_Trade? = nil
}

/// Maximum number of trades per request is 6765
public struct TradesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trades: [Core_Trade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TradesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OpenChannelRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peer: Auth_Peer {
    get {return _peer ?? Auth_Peer()}
    set {_peer = newValue}
  }
  /// Returns true if `peer` has been explicitly set.
  public var hasPeer: Bool {return self._peer != nil}
  /// Clears the value of `peer`. Subsequent reads from it will return its default value.
  public mutating func clearPeer() {self._peer = nil}

  public var marginDeposit: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peer: Auth_Peer? = nil
}

public struct OpenChannelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetJwtRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetJwtResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jwt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CloseChannelRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CloseChannelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SubscribeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Notification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notification: Notification.OneOf_Notification? = nil

  public var streamNotification: StreamNotification {
    get {
      if case .streamNotification(let v)? = notification {return v}
      return StreamNotification()
    }
    set {notification = .streamNotification(newValue)}
  }

  public var settlementNotification: SettlementNotification {
    get {
      if case .settlementNotification(let v)? = notification {return v}
      return SettlementNotification()
    }
    set {notification = .settlementNotification(newValue)}
  }

  public var positionNotification: PositionNotification {
    get {
      if case .positionNotification(let v)? = notification {return v}
      return PositionNotification()
    }
    set {notification = .positionNotification(newValue)}
  }

  public var errorNotification: ErrorNotification {
    get {
      if case .errorNotification(let v)? = notification {return v}
      return ErrorNotification()
    }
    set {notification = .errorNotification(newValue)}
  }

  public var transactionNotification: TransactionNotification {
    get {
      if case .transactionNotification(let v)? = notification {return v}
      return TransactionNotification()
    }
    set {notification = .transactionNotification(newValue)}
  }

  public var sessionKeyTransactionNotification: SessionKeyTransactionNotification {
    get {
      if case .sessionKeyTransactionNotification(let v)? = notification {return v}
      return SessionKeyTransactionNotification()
    }
    set {notification = .sessionKeyTransactionNotification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Notification: Equatable, Sendable {
    case streamNotification(StreamNotification)
    case settlementNotification(SettlementNotification)
    case positionNotification(PositionNotification)
    case errorNotification(ErrorNotification)
    case transactionNotification(TransactionNotification)
    case sessionKeyTransactionNotification(SessionKeyTransactionNotification)

  }

  public init() {}
}

public struct StreamNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var notificationType: NotificationType = .unspecified

  public var channelStatus: ChannelStatus = .unspecified

  public var myRole: Core_ProtocolIndex = .unspecified

  public var peer: Auth_Peer {
    get {return _peer ?? Auth_Peer()}
    set {_peer = newValue}
  }
  /// Returns true if `peer` has been explicitly set.
  public var hasPeer: Bool {return self._peer != nil}
  /// Clears the value of `peer`. Subsequent reads from it will return its default value.
  public mutating func clearPeer() {self._peer = nil}

  public var marginLimitType: Core_MarginLimitType = .unspecified

  public var marginDeposit: String = String()

  /// margin updates will be reflected here
  public var initiatorMarginBalance: String = String()

  /// margin updates will be reflected here
  public var followerMarginBalance: String = String()

  public var turnNum: UInt64 = 0

  public var clearingSmState: StateMachine_ClearingSMState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peer: Auth_Peer? = nil
}

public struct SettlementNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var settlementState: Settlement_SettlementState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PositionNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var position: Core_Position {
    get {return _position ?? Core_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: Core_Position? = nil
}

public struct TransactionNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var to: String = String()

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ErrorNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: String = String()

  public var metadata: ErrorMetadata {
    get {return _metadata ?? ErrorMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: ErrorMetadata? = nil
}

public struct SessionKeyTransactionNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var incompleteUserop: IncompleteUserOp {
    get {return _incompleteUserop ?? IncompleteUserOp()}
    set {_incompleteUserop = newValue}
  }
  /// Returns true if `incompleteUserop` has been explicitly set.
  public var hasIncompleteUserop: Bool {return self._incompleteUserop != nil}
  /// Clears the value of `incompleteUserop`. Subsequent reads from it will return its default value.
  public mutating func clearIncompleteUserop() {self._incompleteUserop = nil}

  public var enableSigOffset: UInt64 = 0

  public var digestHash: String = String()

  public var permissions: [SessionKeyPermission] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _incompleteUserop: IncompleteUserOp? = nil
}

public struct SettlementRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var paymentMethod: Settlement_PaymentMethod = .unspecified

  public var chainID: UInt64 = 0

  public var markets: [Core_Market] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SettlementResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetPositionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetPositionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var positions: [Core_Position] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ErrorMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var state: String = String()

  public var event: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension NotificationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTIFICATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "NOTIFICATION_TYPE_CHANNEL_OPENING"),
    2: .same(proto: "NOTIFICATION_TYPE_CHANNEL_OPENED"),
    3: .same(proto: "NOTIFICATION_TYPE_CHANNEL_CLOSED"),
    4: .same(proto: "NOTIFICATION_TYPE_CHALLENGE_STARTED"),
    5: .same(proto: "NOTIFICATION_TYPE_CHALLENGE_CLEARED"),
    6: .same(proto: "NOTIFICATION_TYPE_CHALLENGE_FINISHED"),
    7: .same(proto: "NOTIFICATION_TYPE_MARGIN_UPDATED"),
  ]
}

extension ChannelStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_STATUS_UNSPECIFIED"),
    1: .same(proto: "CHANNEL_STATUS_OPENING"),
    2: .same(proto: "CHANNEL_STATUS_OPEN"),
    3: .same(proto: "CHANNEL_STATUS_CHALLENGING"),
    4: .same(proto: "CHANNEL_STATUS_CLOSED"),
  ]
}

extension VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VersionRequest, rhs: VersionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VersionResponse, rhs: VersionResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChallengeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChallengeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChallengeRequest, rhs: GetChallengeRequest) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChallengeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChallengeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.challenge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challenge.isEmpty {
      try visitor.visitSingularStringField(value: self.challenge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChallengeResponse, rhs: GetChallengeResponse) -> Bool {
    if lhs.challenge != rhs.challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthenticateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuthenticateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "signature"),
    3: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AuthenticateRequest, rhs: AuthenticateRequest) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthenticateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuthenticateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AuthenticateResponse, rhs: AuthenticateResponse) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TradeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trade"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trade) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trade {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeRequest, rhs: TradeRequest) -> Bool {
    if lhs._trade != rhs._trade {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TradeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trade"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trade) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trade {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeResponse, rhs: TradeResponse) -> Bool {
    if lhs._trade != rhs._trade {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradesRequest, rhs: TradesRequest) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TradesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradesResponse, rhs: TradesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OpenChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OpenChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peer"),
    2: .standard(proto: "margin_deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marginDeposit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.marginDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.marginDeposit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OpenChannelRequest, rhs: OpenChannelRequest) -> Bool {
    if lhs._peer != rhs._peer {return false}
    if lhs.marginDeposit != rhs.marginDeposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OpenChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OpenChannelResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OpenChannelResponse, rhs: OpenChannelResponse) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetJwtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetJwtRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetJwtRequest, rhs: GetJwtRequest) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetJwtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetJwtResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetJwtResponse, rhs: GetJwtResponse) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CloseChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CloseChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CloseChannelRequest, rhs: CloseChannelRequest) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CloseChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CloseChannelResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CloseChannelResponse, rhs: CloseChannelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SubscribeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeRequest, rhs: SubscribeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_notification"),
    2: .standard(proto: "settlement_notification"),
    3: .standard(proto: "position_notification"),
    4: .standard(proto: "error_notification"),
    5: .standard(proto: "transaction_notification"),
    6: .standard(proto: "session_key_transaction_notification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StreamNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .streamNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .streamNotification(v)
        }
      }()
      case 2: try {
        var v: SettlementNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .settlementNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .settlementNotification(v)
        }
      }()
      case 3: try {
        var v: PositionNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .positionNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .positionNotification(v)
        }
      }()
      case 4: try {
        var v: ErrorNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .errorNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .errorNotification(v)
        }
      }()
      case 5: try {
        var v: TransactionNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .transactionNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .transactionNotification(v)
        }
      }()
      case 6: try {
        var v: SessionKeyTransactionNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .sessionKeyTransactionNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .sessionKeyTransactionNotification(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.notification {
    case .streamNotification?: try {
      guard case .streamNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .settlementNotification?: try {
      guard case .settlementNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .positionNotification?: try {
      guard case .positionNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .errorNotification?: try {
      guard case .errorNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .transactionNotification?: try {
      guard case .transactionNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sessionKeyTransactionNotification?: try {
      guard case .sessionKeyTransactionNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Notification, rhs: Notification) -> Bool {
    if lhs.notification != rhs.notification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StreamNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StreamNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "notification_type"),
    3: .standard(proto: "channel_status"),
    4: .standard(proto: "my_role"),
    5: .same(proto: "peer"),
    6: .standard(proto: "margin_limit_type"),
    7: .standard(proto: "margin_deposit"),
    8: .standard(proto: "initiator_margin_balance"),
    9: .standard(proto: "follower_margin_balance"),
    10: .standard(proto: "turn_num"),
    11: .standard(proto: "clearing_sm_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.notificationType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.channelStatus) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.myRole) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._peer) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.marginLimitType) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marginDeposit) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.initiatorMarginBalance) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.followerMarginBalance) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.turnNum) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.clearingSmState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.notificationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.notificationType, fieldNumber: 2)
    }
    if self.channelStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.channelStatus, fieldNumber: 3)
    }
    if self.myRole != .unspecified {
      try visitor.visitSingularEnumField(value: self.myRole, fieldNumber: 4)
    }
    try { if let v = self._peer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.marginLimitType != .unspecified {
      try visitor.visitSingularEnumField(value: self.marginLimitType, fieldNumber: 6)
    }
    if !self.marginDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.marginDeposit, fieldNumber: 7)
    }
    if !self.initiatorMarginBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.initiatorMarginBalance, fieldNumber: 8)
    }
    if !self.followerMarginBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.followerMarginBalance, fieldNumber: 9)
    }
    if self.turnNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.turnNum, fieldNumber: 10)
    }
    if self.clearingSmState != .unspecified {
      try visitor.visitSingularEnumField(value: self.clearingSmState, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StreamNotification, rhs: StreamNotification) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.notificationType != rhs.notificationType {return false}
    if lhs.channelStatus != rhs.channelStatus {return false}
    if lhs.myRole != rhs.myRole {return false}
    if lhs._peer != rhs._peer {return false}
    if lhs.marginLimitType != rhs.marginLimitType {return false}
    if lhs.marginDeposit != rhs.marginDeposit {return false}
    if lhs.initiatorMarginBalance != rhs.initiatorMarginBalance {return false}
    if lhs.followerMarginBalance != rhs.followerMarginBalance {return false}
    if lhs.turnNum != rhs.turnNum {return false}
    if lhs.clearingSmState != rhs.clearingSmState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SettlementNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SettlementNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "settlement_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.settlementState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.settlementState != .unspecified {
      try visitor.visitSingularEnumField(value: self.settlementState, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SettlementNotification, rhs: SettlementNotification) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.settlementState != rhs.settlementState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PositionNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionNotification, rhs: PositionNotification) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransactionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TransactionNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransactionNotification, rhs: TransactionNotification) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ErrorNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ErrorNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "msg"),
    4: .same(proto: "metadata"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ErrorNotification, rhs: ErrorNotification) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionKeyTransactionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionKeyTransactionNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "incomplete_userop"),
    2: .standard(proto: "enable_sig_offset"),
    3: .standard(proto: "digest_hash"),
    4: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._incompleteUserop) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.enableSigOffset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.digestHash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._incompleteUserop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.enableSigOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.enableSigOffset, fieldNumber: 2)
    }
    if !self.digestHash.isEmpty {
      try visitor.visitSingularStringField(value: self.digestHash, fieldNumber: 3)
    }
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionKeyTransactionNotification, rhs: SessionKeyTransactionNotification) -> Bool {
    if lhs._incompleteUserop != rhs._incompleteUserop {return false}
    if lhs.enableSigOffset != rhs.enableSigOffset {return false}
    if lhs.digestHash != rhs.digestHash {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SettlementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SettlementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "payment_method"),
    3: .standard(proto: "chain_id"),
    4: .same(proto: "markets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.paymentMethod) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.chainID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.markets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.paymentMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.paymentMethod, fieldNumber: 2)
    }
    if self.chainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chainID, fieldNumber: 3)
    }
    if !self.markets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.markets, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SettlementRequest, rhs: SettlementRequest) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.paymentMethod != rhs.paymentMethod {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.markets != rhs.markets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SettlementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SettlementResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SettlementResponse, rhs: SettlementResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetPositionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetPositionsRequest, rhs: GetPositionsRequest) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetPositionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "positions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.positions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.positions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetPositionsResponse, rhs: GetPositionsResponse) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ErrorMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ErrorMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    3: .same(proto: "state"),
    4: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 3)
    }
    if !self.event.isEmpty {
      try visitor.visitSingularStringField(value: self.event, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ErrorMetadata, rhs: ErrorMetadata) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
